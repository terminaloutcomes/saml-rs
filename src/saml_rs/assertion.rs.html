<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src/assertion.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>assertion.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../saml_rs/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../saml_rs/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../saml_rs/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‚ÄòS‚Äô to search, ‚Äò?‚Äô for more options‚Ä¶" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
</pre><pre class="rust"><code><span class="doccomment">//! Assertion-related things
//!
//! Assertions *Require* the following (from &lt;http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf&gt; 2.3.3 Element Assertion):

//! * Version - The version of this assertion. The identifier for the version of SAML defined in this specification is &quot;2.0&quot;. SAML versioning is discussed in Section 4.
//! * ID - The identifier for this assertion. It is of type xs:ID, and MUST follow the requirements specified in Section 1.3.4 for identifier uniqueness.
//! * IssueInstant - The time instant of issue in UTC, as described in Section 1.3.3.
//! * Issuer - The SAML authority that is making the claim(s) in the assertion. The issuer SHOULD be unambiguous to the intended relying parties. There&#39;s no requirement for this to be the same as the signer, other than in the design of the consumer.
//!
//! Optional things:
//!
//! * ds:Signature - an XML signature
//! * Subject - The subject of the statement(s) in the assertion.
//! * Conditions - Conditions that MUST be evaluated when assessing the validity of and/or when using the assertion. See Section 2.5 for additional information on how to evaluate conditions.
//! * Advice - Additional information related to the assertion that assists processing in certain situations but which MAY be ignored by applications that do not understand the advice or do not wish to make use of it.
//!
//! Zero or more of the following statement elements:
//!
//! * Statement - A statement of a type defined in an extension schema. An xsi:type attribute MUST be used to indicate the actual statement type.
//! * AuthnStatement - An authentication statement.
//! * AuthzDecisionStatement - An authorization decision statement.
//! * AttributeStatement - An attribute statement.
//!
//! An assertion with no statements MUST contain a \&lt;Subject\&gt; element. Such an assertion identifies a principal in a manner which can be referenced or confirmed using SAML methods, but asserts no further information associated with that principal.

</span><span class="kw">use </span>serde::Serialize;

<span class="kw">use </span><span class="kw">crate</span>::utils::<span class="kw-2">*</span>;
<span class="kw">use </span><span class="kw">crate</span>::xml::write_event;
<span class="kw">use </span>chrono::{DateTime, SecondsFormat, Utc};
<span class="kw">use </span>openssl::x509::X509;
<span class="kw">use </span>std::io::Write;
<span class="kw">use </span>std::str::from_utf8;
<span class="kw">use </span>xml::writer::{EmitterConfig, EventWriter, XmlEvent};

<span class="doccomment">/// AssertionTypes, from &lt;http://docs.oasis-open.org/security/saml/v2.0/saml-schema-assertion-2.0.xsd&gt; ```&lt;complexType name=&quot;AssertionType&quot;&gt;```
</span><span class="attribute">#[allow(dead_code)]
</span><span class="kw">enum </span>AssertionType {
    Statement,
    AuthnStatement,
    AuthzDecisionStatement,
    AttributeStatement,
}

<span class="doccomment">/// StatusCode values
</span><span class="attribute">#[allow(dead_code)]
</span><span class="kw">enum </span>StatusCode {
    <span class="doccomment">/// `urn:oasis:names:tc:SAML:2.0:status:Success`
    </span>Success,
}

<span class="attribute">#[derive(Clone, Debug)]
</span><span class="doccomment">/// The content of an assertion
</span><span class="kw">pub struct </span>Assertion {
    <span class="doccomment">/// Assertion ID, referred to in the signature as ds:Reference
    </span><span class="kw">pub </span>assertion_id: String,
    <span class="doccomment">/// Issuer of the Assertion
    </span><span class="kw">pub </span>issuer: String,
    <span class="doccomment">/// Signing algorithm
    </span><span class="kw">pub </span>signing_algorithm: <span class="kw">crate</span>::sign::SigningAlgorithm,
    <span class="doccomment">/// Digest algorithm
    </span><span class="kw">pub </span>digest_algorithm: <span class="kw">crate</span>::sign::DigestAlgorithm,
    <span class="doccomment">/// Issue/Generatino time of the Assertion
    </span><span class="kw">pub </span>issue_instant: DateTime&lt;Utc&gt;,
    <span class="doccomment">/// TODO: work out what is necessary for [SubjectData]
    </span><span class="kw">pub </span>subject_data: SubjectData,
    <span class="doccomment">/// Please don&#39;t let the user do this until ... now!
    </span><span class="kw">pub </span>conditions_not_before: DateTime&lt;Utc&gt;,
    <span class="doccomment">/// Please don&#39;t let the user do whatever we&#39;re saying they can do after this.
    </span><span class="kw">pub </span>conditions_not_after: DateTime&lt;Utc&gt;,
    <span class="doccomment">/// Who/what should be reading this. Probably a [crate::sp::ServiceProvider]
    </span><span class="kw">pub </span>audience: String,
    <span class="doccomment">/// Attributes of the assertion, things like groups and email addresses and phone numbers and favourite kind of ü•îüç†
    </span><span class="kw">pub </span>attributes: Vec&lt;AssertionAttribute&gt;,

    <span class="doccomment">/// Should we sign the assertion?
    </span><span class="kw">pub </span>sign_assertion: bool,

    <span class="doccomment">/// an openssl private key for signing
    </span><span class="kw">pub </span>signing_key: <span class="prelude-ty">Option</span>&lt;openssl::pkey::PKey&lt;openssl::pkey::Private&gt;&gt;,
    <span class="doccomment">/// Certificate for signing/digest
    </span><span class="kw">pub </span>signing_cert: <span class="prelude-ty">Option</span>&lt;X509&gt;,
}

<span class="kw">fn </span>write_assertion_tmpdir(buffer: <span class="kw-2">&amp;</span>[u8]) {
    <span class="kw">let </span><span class="kw-2">mut </span>assertionpath = std::env::temp_dir();
    <span class="kw">let </span><span class="kw-2">mut </span>assertionfilename: String = chrono::Utc::now().timestamp().to_string();
    assertionfilename.push_str(<span class="string">&quot;-assertionout.xml&quot;</span>);
    assertionpath.set_file_name(assertionfilename);
    <span class="macro">log::debug!</span>(<span class="string">&quot;Assertion filename: {:?}&quot;</span>, <span class="kw-2">&amp;</span>assertionpath);
    <span class="kw">let </span><span class="kw-2">mut </span>assertionfile = <span class="kw">match </span>std::fs::OpenOptions::new()
        .create(<span class="bool-val">true</span>)
        .write(<span class="bool-val">true</span>)
        <span class="comment">// either use ? or unwrap since it returns a Result
        </span>.open(assertionpath.into_os_string())
    {
        <span class="prelude-val">Ok</span>(value) =&gt; value,
        <span class="prelude-val">Err</span>(e) =&gt; {
            <span class="macro">log::error!</span>(<span class="string">&quot;Failed to open assertionout {:?}&quot;</span>, e);
            std::process::exit(<span class="number">1</span>)
        }
    };

    <span class="kw">match </span>assertionfile.write_all(<span class="kw-2">&amp;</span>buffer) {
        <span class="prelude-val">Ok</span>(value) =&gt; <span class="macro">log::debug!</span>(<span class="string">&quot;{:?}&quot;</span>, value),
        <span class="prelude-val">Err</span>(e) =&gt; <span class="macro">log::error!</span>(<span class="string">&quot;{:?}&quot;</span>, e),
    };
}

<span class="doccomment">/// Creates a String full of XML based on the ResponsElements
</span><span class="attribute">#[allow(clippy::from_over_into)]
</span><span class="kw">impl </span>Into&lt;Vec&lt;u8&gt;&gt; <span class="kw">for </span>Assertion {
    <span class="kw">fn </span>into(<span class="self">self</span>) -&gt; Vec&lt;u8&gt; {
        <span class="comment">// TODO: implement into vec u8 for assertion so we can sign it

        </span><span class="kw">let </span><span class="kw-2">mut </span>buffer = Vec::new();
        <span class="kw">let </span><span class="kw-2">mut </span>writer = EmitterConfig::new()
            .perform_indent(<span class="bool-val">true</span>)
            .pad_self_closing(<span class="bool-val">false</span>)
            .write_document_declaration(<span class="bool-val">false</span>)
            .normalize_empty_elements(<span class="bool-val">false</span>)
            .create_writer(<span class="kw-2">&amp;mut </span>buffer);

        <span class="self">self</span>.add_assertion_to_xml(<span class="kw-2">&amp;mut </span>writer);
        <span class="macro">log::debug!</span>(<span class="string">&quot;Assertion into vec result:&quot;</span>);
        <span class="macro">log::debug!</span>(<span class="string">&quot;{}&quot;</span>, from_utf8(<span class="kw-2">&amp;</span>buffer).unwrap());

        write_assertion_tmpdir(<span class="kw-2">&amp;</span>buffer);
        buffer
    }
}

<span class="kw">impl </span>Assertion {
    <span class="doccomment">/// This exists so we can return a copy of an [Assertion] without the signature flags so we can trigger [Assertion.Into&lt;Vec&lt;u8&gt;&gt;] for signing
    </span><span class="kw">pub fn </span>without_signature(<span class="self">self</span>) -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{
            assertion_id: <span class="self">self</span>.assertion_id,
            issuer: <span class="self">self</span>.issuer,
            signing_algorithm: <span class="self">self</span>.signing_algorithm,
            digest_algorithm: <span class="self">self</span>.digest_algorithm,
            issue_instant: <span class="self">self</span>.issue_instant,
            subject_data: <span class="self">self</span>.subject_data,
            conditions_not_before: <span class="self">self</span>.conditions_not_before,
            conditions_not_after: <span class="self">self</span>.conditions_not_after,
            audience: <span class="self">self</span>.audience,
            attributes: <span class="self">self</span>.attributes,
            sign_assertion: <span class="bool-val">false</span>,
            signing_key: <span class="self">self</span>.signing_key,
            signing_cert: <span class="self">self</span>.signing_cert,
        }
    }

    <span class="doccomment">/// Build an assertion based on the Assertion, returns a String of XML.
    ///
    /// If you set sign, it&#39;ll sign the data.. eventually.
    </span><span class="kw">pub fn </span>build_assertion(<span class="kw-2">&amp;</span><span class="self">self</span>, sign: bool) -&gt; String {
        <span class="kw">if </span>sign {
            <span class="macro">unimplemented!</span>(<span class="string">&quot;Still need to refactor building the signed assertion&quot;</span>)
        } <span class="kw">else </span>{
            <span class="macro">unimplemented!</span>(<span class="string">&quot;Still need to refactor building the assertion&quot;</span>)
        }
        <span class="comment">// String::from(&quot;Uh.. wait up.&quot;)
    </span>}

    <span class="doccomment">/// adds a `saml:Conditions` statement to the writer
    </span><span class="kw">fn </span>add_conditions&lt;W: Write&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, writer: <span class="kw-2">&amp;mut </span>EventWriter&lt;W&gt;) {
        <span class="comment">// start conditions statement
        </span>write_event(
            XmlEvent::start_element((<span class="string">&quot;saml&quot;</span>, <span class="string">&quot;Conditions&quot;</span>))
                <span class="comment">// TODO: conditions_not_before
                </span>.attr(<span class="string">&quot;NotBefore&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.conditions_not_before.to_rfc3339())
                <span class="comment">// TODO: conditions_not_after
                </span>.attr(<span class="string">&quot;NotOnOrAfter&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.conditions_not_after.to_rfc3339())
                .into(),
            writer,
        );

        write_event(
            XmlEvent::start_element((<span class="string">&quot;saml&quot;</span>, <span class="string">&quot;AudienceRestriction&quot;</span>)).into(),
            writer,
        );
        write_event(XmlEvent::start_element((<span class="string">&quot;saml&quot;</span>, <span class="string">&quot;Audience&quot;</span>)).into(), writer);
        <span class="comment">// TODO: BUG: this is wrong. Assertion contains an unacceptable AudienceRestriction.
        </span>write_event(XmlEvent::characters(<span class="kw-2">&amp;</span><span class="self">self</span>.audience), writer);
        write_event(XmlEvent::end_element().into(), writer);
        write_event(XmlEvent::end_element().into(), writer);
        <span class="comment">// end conditions statement
        </span>write_event(XmlEvent::end_element().into(), writer);
    }

    <span class="doccomment">/// This adds the data from an Assertion to a given EventWriter.
    ///
    /// If you specify to *sign* the assertion, it&#39;s going to:
    /// - generate a temporary EventWriter
    /// - generate the *unsigned* assertion
    /// - add the signature to the assertion
    /// - weep quietly
    /// - return the full pack
    ///
    /// That&#39;s the plan, anyway.
    ///
    /// ``` xml
    /// # Assertion Header
    /// - AttributeStatement
    /// - AuthnStatement
    /// - Conditions
    /// - Issuer
    /// - Signature
    /// - Subject
    /// # End Assertion
    /// ```
    ///
    </span><span class="kw">pub fn </span>add_assertion_to_xml&lt;W: Write&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, writer: <span class="kw-2">&amp;mut </span>EventWriter&lt;W&gt;) {
        <span class="comment">// start the assertion
        </span><span class="macro">log::debug!</span>(<span class="string">&quot;sign_assertion: {}&quot;</span>, <span class="self">self</span>.sign_assertion);

        write_event(
            XmlEvent::start_element((<span class="string">&quot;saml&quot;</span>, <span class="string">&quot;Assertion&quot;</span>))
                .attr(<span class="string">&quot;xmlns:saml&quot;</span>, <span class="string">&quot;urn:oasis:names:tc:SAML:2.0:assertion&quot;</span>)
                .attr(<span class="string">&quot;ID&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.assertion_id)
                .attr(
                    <span class="string">&quot;IssueInstant&quot;</span>,
                    <span class="kw-2">&amp;</span><span class="self">self
                        </span>.issue_instant
                        .to_rfc3339_opts(SecondsFormat::Secs, <span class="bool-val">true</span>),
                )
                .attr(<span class="string">&quot;Version&quot;</span>, <span class="string">&quot;2.0&quot;</span>) <span class="comment">// yeah, not going to support anything but 2.0 here. üòÖ
                </span>.into(),
            writer,
        );

        <span class="comment">// do the issuer inside the assertion
        </span>write_event(XmlEvent::start_element((<span class="string">&quot;saml&quot;</span>, <span class="string">&quot;Issuer&quot;</span>)).into(), writer);
        write_event(XmlEvent::characters(<span class="kw-2">&amp;</span><span class="self">self</span>.issuer), writer);
        write_event(XmlEvent::end_element().into(), writer);

        <span class="comment">// if the assertion needs to be signed, we need to generate the whole assertion as a string, sign that, then add it to this assertion.
        </span><span class="kw">if </span><span class="self">self</span>.sign_assertion {
            <span class="macro">log::debug!</span>(<span class="string">&quot;Signing assertion&quot;</span>);
            <span class="kw">if </span><span class="self">self</span>.signing_key.is_none() {
                <span class="macro">panic!</span>(<span class="string">&quot;You tried to sign an assertion without setting a signing key...&quot;</span>);
            }

            <span class="comment">// 1. generate the assertion, a big lump of XML
            </span><span class="kw">let </span>unsigned_assertion = <span class="self">self</span>.clone().without_signature();
            <span class="kw">let </span>xmldata: Vec&lt;u8&gt; = unsigned_assertion.into();

            <span class="comment">// 2. take a hash of that.
            </span><span class="kw">let </span>digest_bytes = <span class="self">self</span>.digest_algorithm.hash(<span class="kw-2">&amp;</span>xmldata).unwrap();

            <span class="comment">// 3. base64 encode #2
            </span><span class="kw">let </span>base64_encoded_digest = base64::encode(<span class="kw-2">&amp;</span>digest_bytes);

            <span class="comment">// 4. you put #3 into ANOTHER chunk of XML.
            </span><span class="kw">let </span><span class="kw-2">mut </span>signedinfo_buffer = Vec::new();
            <span class="kw">let </span><span class="kw-2">mut </span>signedinfo_writer = EmitterConfig::new()
                .perform_indent(<span class="bool-val">true</span>)
                .write_document_declaration(<span class="bool-val">false</span>)
                .normalize_empty_elements(<span class="bool-val">true</span>)
                .pad_self_closing(<span class="bool-val">false</span>)
                .create_writer(<span class="kw-2">&amp;mut </span>signedinfo_buffer);

            <span class="kw">crate</span>::xml::generate_signedinfo(<span class="self">self</span>, <span class="kw-2">&amp;</span>base64_encoded_digest, <span class="kw-2">&amp;mut </span>signedinfo_writer);
            <span class="macro">log::debug!</span>(<span class="string">&quot;SignedInfo Element:&quot;</span>);
            <span class="macro">log::debug!</span>(<span class="string">&quot;{}&quot;</span>, from_utf8(<span class="kw-2">&amp;</span>signedinfo_buffer).unwrap());

            <span class="comment">// 5. you hash #4.
            </span><span class="kw">let </span>hashed_signedinfo = base64::encode(signedinfo_buffer);
            <span class="macro">log::debug!</span>(<span class="string">&quot;Hashed Signedinfo: {}&quot;</span>, hashed_signedinfo);

            <span class="comment">// 6. you sign #5
            </span><span class="kw">let </span>key = <span class="self">self</span>.signing_key.as_ref().unwrap();
            <span class="kw">let </span>signed_result =
                <span class="kw">crate</span>::sign::sign_data(<span class="self">self</span>.signing_algorithm, key, <span class="kw-2">&amp;</span>hashed_signedinfo.as_bytes());
            <span class="macro">log::debug!</span>(<span class="string">&quot;Signature result: {:?}&quot;</span>, <span class="kw-2">&amp;</span>signed_result);

            <span class="kw">let </span>base64_encoded_signature = base64::encode(<span class="kw-2">&amp;</span>signed_result);
            <span class="macro">log::debug!</span>(
                <span class="string">&quot;Base64 encoded signature result: {:?}&quot;</span>,
                <span class="kw-2">&amp;</span>base64_encoded_signature
            );

            <span class="comment">// 7. then you put #4 and #6 inside some other xml inside #1.

            </span><span class="kw">crate</span>::xml::add_assertion_signature(
                <span class="self">self</span>,
                base64_encoded_digest,
                base64_encoded_signature,
                writer,
            );
        } <span class="kw">else </span>{
            <span class="comment">// add an extra newline to the thing before signing, per https://www.di-mgt.com.au/xmldsig2.html
            // the spaces indent the next tag...
            </span>write_event(XmlEvent::characters(<span class="string">&quot;\n  \n  &quot;</span>), writer);

            <span class="macro">log::warn!</span>(<span class="string">&quot;Unsigned assertion was built, this seems bad!&quot;</span>);
        }

        <span class="comment">// add the subject to the assertion
        </span>add_subject(<span class="kw-2">&amp;</span><span class="self">self</span>.subject_data, writer);

        <span class="self">self</span>.add_conditions(writer);

        <span class="comment">// To do an expiry in an hour, do this
        // let session_expiry = Utc::now().checked_add_signed(Duration::seconds(3600));

        // self.authnstatement.add_to_xmlevent(&amp;mut writer);

        // start the AttributeStatement
        </span>write_event(
            XmlEvent::start_element((<span class="string">&quot;saml&quot;</span>, <span class="string">&quot;AttributeStatement&quot;</span>)).into(),
            writer,
        );
        <span class="kw">for </span>attribute <span class="kw">in </span><span class="kw-2">&amp;</span><span class="self">self</span>.attributes.to_vec() {
            add_attribute(attribute, writer);
        }

        <span class="comment">// end saml:AttributeStatement
        </span>write_event(XmlEvent::end_element().into(), writer);

        <span class="comment">// end the assertion
        </span>write_event(XmlEvent::end_element().into(), writer);
    }
}

<span class="attribute">#[derive(Debug, Copy, Clone)]
</span><span class="doccomment">/// Type of `saml:NameId` in a statement.
///
/// &quot;There can be 0 or more of NameQualifier or SPNameQualifier.&quot;
///
/// I must have been reading the spec again.
///
/// They look like this:
/// ```xml
/// &lt;saml:NameID SPNameQualifier=&quot;http://sp.example.com/demo1/metadata.php&quot; Format=&quot;urn:oasis:names:tc:SAML:2.0:nameid-format:transient&quot;&gt;_ce3d2948b4cf20146dee0a0b3dd6f69b6cf86f62d7&lt;/saml:NameID&gt;
/// ```
</span><span class="kw">pub enum </span>BaseIDAbstractType {
    <span class="doccomment">///
    </span>NameQualifier,
    <span class="doccomment">/// This&#39;ll be the one you normally use -¬†TODO I think this comes from the metadata itself
    </span>SPNameQualifier,
}

<span class="kw">impl </span>From&lt;String&gt; <span class="kw">for </span>BaseIDAbstractType {
    <span class="kw">fn </span>from(name: String) -&gt; <span class="self">Self </span>{
        <span class="kw">let </span>name = name.as_str();
        <span class="kw">match </span>name {
            <span class="string">&quot;NameQualifier&quot; </span>=&gt; BaseIDAbstractType::NameQualifier,
            <span class="string">&quot;SPNameQualifier&quot; </span>=&gt; BaseIDAbstractType::SPNameQualifier,
            <span class="kw">_ </span>=&gt; <span class="macro">panic!</span>(<span class="string">&quot;how did you even get here&quot;</span>),
        }
    }
}

<span class="kw">impl </span>ToString <span class="kw">for </span>BaseIDAbstractType {
    <span class="kw">fn </span>to_string(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; String {
        <span class="kw">match </span><span class="self">self </span>{
            BaseIDAbstractType::NameQualifier =&gt; String::from(<span class="string">&quot;NameQualifier&quot;</span>),
            BaseIDAbstractType::SPNameQualifier =&gt; String::from(<span class="string">&quot;SPNameQualifier&quot;</span>),
        }
    }
}

<span class="comment">// // use xml::name::Name;
// use std::convert::From;

// impl From&lt;xml::name::Name&gt; for BaseIDAbstractType{
//     fn from(name: Name) -&gt; Self {
//         self.from_string(name.to_string())
//     }
// }

</span><span class="attribute">#[derive(Clone, Debug)]
</span><span class="doccomment">/// Data type for passing subject data in because yeaaaaah, specs
///
/// TODO: Justify the existence of the elements of this struct ... more completely.
</span><span class="kw">pub struct </span>SubjectData {
    <span class="doccomment">/// Relay state as provided by the [crate::AuthnRequest]
    </span><span class="kw">pub </span>relay_state: String,
    <span class="doccomment">/// Qualifier TODO: What&#39;s the qualifier again?
    </span><span class="kw">pub </span>qualifier: <span class="prelude-ty">Option</span>&lt;BaseIDAbstractType&gt;,
    <span class="doccomment">/// Qualifier value TODO: I really should know what these are
    </span><span class="kw">pub </span>qualifier_value: <span class="prelude-ty">Option</span>&lt;String&gt;,
    <span class="doccomment">/// [crate::sp::NameIdFormat], what kind of format you&#39;re... going TODO oh no I&#39;ve done it again
    </span><span class="kw">pub </span>nameid_format: <span class="kw">crate</span>::sp::NameIdFormat,
    <span class="doccomment">/// NameID value - I know this one, it&#39;s the reference to the user, like username or some rando noise if it&#39;s transient. Regret, if it&#39;s [crate::sp::NameIdFormat::Kerberos]
    </span><span class="kw">pub </span>nameid_value: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str,
    <span class="doccomment">/// The AssertionConsumerService - where we&#39;ll send the request.
    </span><span class="kw">pub </span>acs: String,
    <span class="doccomment">/// The expiry of this Assertion. Woo, recovered there at the end.
    </span><span class="kw">pub </span>subject_not_on_or_after: DateTime&lt;Utc&gt;,
}

<span class="doccomment">/// Adds the Subject statement to an assertion
</span><span class="kw">fn </span>add_subject&lt;W: Write&gt;(subjectdata: <span class="kw-2">&amp;</span>SubjectData, writer: <span class="kw-2">&amp;mut </span>EventWriter&lt;W&gt;) {
    <span class="comment">// start subject statement
    </span>write_event(XmlEvent::start_element((<span class="string">&quot;saml&quot;</span>, <span class="string">&quot;Subject&quot;</span>)).into(), writer);
    <span class="comment">// start nameid statement
    // TODO: nameid can be 0 or more of NameQualifier or SPNameQualifier
    </span>write_event(
        XmlEvent::start_element((<span class="string">&quot;saml&quot;</span>, <span class="string">&quot;NameID&quot;</span>))
            .attr(<span class="string">&quot;Format&quot;</span>, <span class="kw-2">&amp;</span>subjectdata.nameid_format.to_string())
            .attr(
                subjectdata.qualifier.unwrap().to_string().as_str(),
                subjectdata.qualifier_value.as_ref().unwrap(),
            )
            .into(),
        writer,
    );

    write_event(XmlEvent::characters(<span class="kw-2">&amp;</span>subjectdata.nameid_value), writer);
    <span class="comment">// end nameid statement
    </span>write_event(XmlEvent::end_element().into(), writer);

    <span class="comment">//start subjectconfirmation
    </span>write_event(
        XmlEvent::start_element((<span class="string">&quot;saml&quot;</span>, <span class="string">&quot;SubjectConfirmation&quot;</span>))
            .attr(<span class="string">&quot;Method&quot;</span>, <span class="string">&quot;urn:oasis:names:tc:SAML:2.0:cm:bearer&quot;</span>)
            .into(),
        writer,
    );

    <span class="comment">//start subjectconfirmationdata
    </span>write_event(
        XmlEvent::start_element((<span class="string">&quot;saml&quot;</span>, <span class="string">&quot;SubjectConfirmationData&quot;</span>))
            .attr(<span class="string">&quot;InResponseTo&quot;</span>, <span class="kw-2">&amp;</span>subjectdata.relay_state)
            .attr(
                <span class="string">&quot;NotOnOrAfter&quot;</span>,
                <span class="kw-2">&amp;</span>subjectdata
                    .subject_not_on_or_after
                    .to_saml_datetime_string(),
            )
            .attr(<span class="string">&quot;Recipient&quot;</span>, <span class="kw-2">&amp;</span>subjectdata.acs)
            .into(),
        writer,
    );

    <span class="comment">//end subjectconfirmationdata
    </span>write_event(XmlEvent::end_element().into(), writer);
    <span class="comment">//end subjectconfirmation
    </span>write_event(XmlEvent::end_element().into(), writer);

    write_event(XmlEvent::end_element().into(), writer);
    <span class="comment">// end subject statement
</span>}
<span class="comment">// let mut animals: [&amp;str; 2] = [&quot;bird&quot;, &quot;frog&quot;];
</span><span class="attribute">#[derive(Debug, Default, Serialize, Clone)]
</span><span class="doccomment">/// Attributes for responses
</span><span class="kw">pub struct </span>AssertionAttribute {
    name: String,
    nameformat: String,
    values: Vec&lt;<span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str&gt;,
}

<span class="kw">impl </span>AssertionAttribute {
    <span class="doccomment">/// new Response Attribute with `attrname-format:basic`
    </span><span class="kw">pub fn </span>basic(name: <span class="kw-2">&amp;</span>str, values: Vec&lt;<span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str&gt;) -&gt; AssertionAttribute {
        AssertionAttribute {
            name: name.to_string(),
            nameformat: <span class="string">&quot;urn:oasis:names:tc:SAML:2.0:attrname-format:basic&quot;</span>.to_string(),
            values,
        }
    }
}

<span class="doccomment">/// add an attribute to the statement
</span><span class="kw">pub fn </span>add_attribute&lt;W: Write&gt;(attr: <span class="kw-2">&amp;</span>AssertionAttribute, writer: <span class="kw-2">&amp;mut </span>EventWriter&lt;W&gt;) {
    write_event(
        XmlEvent::start_element((<span class="string">&quot;saml&quot;</span>, <span class="string">&quot;Attribute&quot;</span>))
            .attr(<span class="string">&quot;Name&quot;</span>, attr.name.as_str())
            .attr(<span class="string">&quot;NameFormat&quot;</span>, attr.nameformat.as_str())
            .into(),
        writer,
    );
    <span class="kw">for </span>value <span class="kw">in </span><span class="kw-2">&amp;</span>attr.values {
        write_event(
            XmlEvent::start_element((<span class="string">&quot;saml&quot;</span>, <span class="string">&quot;AttributeValue&quot;</span>))
                .attr(<span class="string">&quot;xmlns:xsi&quot;</span>, <span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>) <span class="comment">// TODO: moved 2021-08-26 to make c14n work, is this valid, or is it going to bite me
                </span>.attr(<span class="string">&quot;xsi:type&quot;</span>, <span class="string">&quot;xs:string&quot;</span>)
                .into(),
            writer,
        );
        write_event(XmlEvent::characters(value), writer);
        write_event(XmlEvent::end_element().into(), writer);
    }
    <span class="comment">// write_event(XmlEvent::end_element().into(), writer);
    </span>write_event(XmlEvent::end_element().into(), writer);
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="saml_rs" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>