#![deny(warnings)]
#![warn(unused_extern_crates)]
#![deny(clippy::todo)]
#![deny(clippy::unimplemented)]
#![deny(clippy::unwrap_used)]
#![deny(clippy::expect_used)]
#![deny(clippy::panic)]
#![deny(clippy::unreachable)]
#![deny(clippy::await_holding_lock)]
#![deny(clippy::needless_pass_by_value)]
#![deny(clippy::trivially_copy_pass_by_ref)]
#![deny(unsafe_code)]
#![warn(missing_docs)]
#![deny(missing_debug_implementations)]

//! A library for doing SAML things, terribly (so far), in rust.
//!
//! If you would like to help - please log PRs/Issues against [terminaloutcomes/saml-rs](https://github.com/terminaloutcomes/saml-rs).
//!
//! There's a test application [saml_test_server](../saml_test_server/index.html) based on [tide](https://docs.rs/tide/) to allow one to test functionality.
//!
//! # Next steps:
//!
//! - Support the SAML 2.0 Web Browser SSO (SP Redirect Bind/ IdP POST Response) flow
//! - Sign responses
//! - Support Signed AuthN Redirect Requests
//!
//! # SAML 2.0 Web Browser SSO (SP Redirect Bind/ IdP POST Response) flow
//!
//! 1. User attempts to access the SP resource (eg `https://example.com/application`)
//! 2. User is HTTP 302 redirected to the IdP (that's us!)
//!    - The URL is provided in the SAML2.0 metadata from the IdP
//!    - There should be two query parameters, [SAMLRequest](SamlQuery::SAMLRequest) and [RelayState](SamlQuery::RelayState) details about them are available in [SamlQuery]
//! 3. The SSO Service validates the request and responds with a document containing an XHTML form:
//!
//!       NOTE: POSTed assertions MUST be signed
//!
//! ```html
//! <form method="post" action="https://example.com/SAML2/SSO/POST" ...>
//!   <input type="hidden" name="SAMLResponse" value="response" />
//!   <input type="hidden" name="RelayState" value="token" />
//! etc etc...
//! <input type="submit" value="Submit" />
//! </form>
//! ```
//! 4. Request the Assertion Consumer Service at the SP. The user agent issues a POST request to the Assertion Consumer Service at the service provider:
//!
//! ```html
//! POST /SAML2/SSO/POST HTTP/1.1
//! Host: sp.example.com
//! Content-Type: application/x-www-form-urlencoded
//! Content-Length: nnn
//! SAMLResponse=response&RelayState=token
//! ```
//!
//! To automate the submission of the form, the following line of JavaScript may appear anywhere on the XHTML page:
//!
//! ```javascript
//! window.onload = function () { document.forms[0].submit(); }
//! ```
//!
//! # Testing tools:
//!
//! * Idp/SP online tester - <https://samltest.id/>
//! * Parser for requests and responses: <https://samltool.io>
//! * OneLogin SAMLTool - <https://www.samltool.com/validate_xml.php> great for validating things against schema.

use base64::{Engine as _, engine::general_purpose::STANDARD as BASE64_STANDARD};
use inflate::inflate_bytes;
use log::debug;
use serde::Serialize;
use std::convert::TryFrom;
use std::fmt;
use std::str::from_utf8;
use xmlparser::{ElementEnd, StrSpan, Token};
pub mod assertion;
pub mod cert;
pub mod constants;
pub mod content_encryption;
pub mod encrypted_assertion_parser;

pub mod encrypted_assertion;
pub mod metadata;
pub mod response;
pub mod security;
pub mod sign;
pub mod sp;
pub mod test_samples;
pub mod utils;
pub mod xml;

// #[cfg(feature = "enable_tide")]
// pub mod tide_helpers;
use serde::Deserialize;

use chrono::{DateTime, SecondsFormat, Utc};

/// Stores the values one would expect in an AuthN Request
#[derive(Debug, Serialize)]
pub struct AuthnRequest {
    #[serde(rename = "ID")]
    /// Request ID provided in the AuthnRequest root ID attribute.
    pub request_id: String,
    #[serde(rename = "IssueInstant")]
    /// AuthN request issue time, generated by the SP - or shoved in by the IdP when parsing if missing
    // TODO: find out if the IdP can just decide on this
    pub issue_instant: DateTime<Utc>,
    #[serde(rename = "AssertionConsumerServiceURL")]
    /// Consumer URL - where the SP wants you to send responses to
    pub consumer_service_url: String,
    /// Issuer of the request - used for matching to the SP-provided metadata.
    ///
    /// This is a nested element inside a `<saml:Issuer xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion">`
    pub issuer: String,
    #[serde(rename = "Version")]
    /// This better be 2.0!
    pub version: String,
    #[serde(rename = "Destination")]
    /// Destination...
    /// TODO: work out if/why this is different to the ACS
    pub destination: String,

    // Example value http%3A%2F%2Fwww.w3.org%2F2001%2F04%2Fxmldsig-more%23rsa-sha256
    #[serde(rename = "SigAlg")]
    /// Signature algorithm, if the request is signed
    pub sigalg: Option<String>,

    // Example signature value Signature=HlQbshvUcfvRY1DYo3B8PJfu%2F32pkFnKNkVtQ%2Fjn%2Bl9DurSUa4DrZH76StCwH1qgJ34v%2FXEfXBPy%2BK79ryojzUs5JR7R1KvlMR%2Fzfvgz7LFGv1fGUIFA9vnbbMsn7G%2FI0%2FXSaFkWiXp9%2BmqTmiBBBhFLsd9A8shXIEjnLVWZNUGR73HwUhEiURhGGAmVkPPGDRW1gU%2BwVdy4YUcsGusqTNEcKvUHZeOe0FC%2BggZ%2BRmCCjr2lTVrAxlXMeNU4NkgBk9VimMFCLA2A6LZ9mtLDn20CHaMEkCbSIessWKfXfz7aXd1VaY6lO1K0aSZ0h3%2BAYRcXcNVl3uvZQUslxh48Nw%3D%3D
    #[serde(rename = "Signature")]
    /// Signature, if signed
    pub signature: Option<String>,
}

impl AuthnRequest {
    /// Return the issue instant in the required form
    pub fn issue_instant_string(&self) -> String {
        self.issue_instant
            .to_rfc3339_opts(SecondsFormat::Secs, true)
    }
}

impl TryFrom<AuthnRequestParser> for AuthnRequest {
    type Error = AuthnDecodeError;

    fn try_from(parser: AuthnRequestParser) -> Result<Self, Self::Error> {
        let request_id = match parser.request_id {
            Some(value) => value,
            None => {
                return Err(AuthnDecodeError::new(
                    "AuthnRequestParser missing request_id".to_string(),
                ));
            }
        };
        let issue_instant = match parser.issue_instant {
            Some(value) => value,
            None => {
                return Err(AuthnDecodeError::new(
                    "AuthnRequestParser missing issue_instant".to_string(),
                ));
            }
        };
        let consumer_service_url = match parser.consumer_service_url {
            Some(value) => value,
            None => {
                return Err(AuthnDecodeError::new(
                    "AuthnRequestParser missing consumer_service_url".to_string(),
                ));
            }
        };
        let issuer = match parser.issuer {
            Some(value) => value,
            None => {
                return Err(AuthnDecodeError::new(
                    "AuthnRequestParser missing issuer".to_string(),
                ));
            }
        };
        let destination = match parser.destination {
            Some(value) => value,
            None => {
                return Err(AuthnDecodeError::new(
                    "AuthnRequestParser missing destination".to_string(),
                ));
            }
        };

        Ok(AuthnRequest {
            request_id,
            issue_instant,
            consumer_service_url,
            issuer,
            version: parser.version,
            destination,
            sigalg: parser.sigalg,
            signature: parser.signature,
        })
    }
}

/// Used to pull apart a SAML AuthN Request and build a [AuthnRequest]
#[derive(Debug, Default)]
pub struct AuthnRequestParser {
    /// Request ID as provided in AuthnRequest root ID attribute.
    pub request_id: Option<String>,
    /// AuthN request issue time, generated by the SP - or shoved in by the IdP when parsing if missing
    // TODO: find out if the IdP can just decide on this
    pub issue_instant: Option<DateTime<Utc>>,
    /// Consumer URL - where the SP wants you to send responses to
    pub consumer_service_url: Option<String>,
    /// Issuer of the request - used for matching to the SP-provided metadata.
    ///
    /// This is a nested element inside a `<saml:Issuer xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion">`
    pub issuer: Option<String>,
    /// This better be 2.0!
    pub version: String,
    /// Internal state id for the issuer
    // TODO: see if I can remove this because I think I replaced this with previous_name
    pub issuer_state: i8,
    /// Destination...
    // TODO: work out if/why this is different to the ACS
    pub destination: Option<String>,
    // TODO: need to parse the name-id policy ```<samlp:NameIDPolicy AllowCreate="true" Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"/>```
    /// Signature algorithm, if the request is signed
    pub sigalg: Option<String>,
    /// Signature algorithm, if the request is signed
    ///
    /// We leave this as the string while returning from the parser, so the [AuthnRequest] can verify it.
    pub signature: Option<String>,
}

impl AuthnRequestParser {
    /// Generate a new [AuthnRequestParser]
    pub fn new() -> Self {
        AuthnRequestParser {
            request_id: None,
            issue_instant: None,
            consumer_service_url: None,
            issuer: None,
            version: String::from("2.0"),
            issuer_state: 0,
            destination: None,
            sigalg: None,
            signature: None,
        }
    }
}

/// Custom error for failing to parse an AuthN request
pub struct AuthnDecodeError {
    /// Error message
    pub message: String,
}

impl AuthnDecodeError {
    /// Generatin' a new AuthDecodeError
    pub fn new(message: String) -> AuthnDecodeError {
        AuthnDecodeError { message }
    }
}

// A unique format for dubugging output
impl fmt::Debug for AuthnDecodeError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "AuthnDecodeError {{ message: {} }}", self.message)
    }
}

#[derive(Deserialize, Debug)]
#[allow(non_snake_case)]
/// Used in the SAML Redirect GET request to pull out the query values
///
/// Snake case is needed to allow the fields to be pulled out correctly
pub struct SamlQuery {
    /// The value of the SAMLRequest parameter is a deflated, base64-encoded and URL-encoded value of an `<samlp:[AuthnRequest]>` element. The SAMLRequest *may* be signed using the SP signing key.
    pub SAMLRequest: Option<String>,
    /// The RelayState token is an opaque reference to state information maintained at the service provider.
    pub RelayState: Option<String>,
    /// Stores a base64-encoded signature...
    /// TODO: isÂ Signature *just* a base64 encoded string? Is there other decoding needed? Can we store this as a better type?
    pub Signature: Option<String>,
    /// Stores the signature type - this should be URL-decoded by the web frontend
    // TODO: uhh... signature enums?
    pub SigAlg: Option<String>,
}

/// Does the decoding to hand the signature to the verifier
// TODO: is string the best retval for decode_authn_request_signature?
pub fn decode_authn_request_signature(signature: String) -> String {
    debug!("signature: {:?}", signature);
    signature
}

/// Removes base64 encoding and also deflates the input String.
pub fn decode_authn_request_base64_encoded(req: String) -> Result<String, AuthnDecodeError> {
    let base64_decoded_samlrequest: Vec<u8> = match BASE64_STANDARD.decode(req) {
        Ok(value) => {
            debug!("Successfully Base64 Decoded the SAMLRequest");
            value
        }
        Err(err) => {
            return Err(AuthnDecodeError::new(format!(
                "Failed to base64 decode SAMLRequest in saml_redirect_get {:?}",
                err
            )));
        }
    };
    // here we try and use libflate to deflate the base64-decoded bytes because compression is used
    let inflated_result = match inflate_bytes(&base64_decoded_samlrequest) {
        Ok(value) => {
            debug!(
                "Successfully inflated the base64-decoded bytes: {:?}",
                from_utf8(&value).unwrap_or("Couldn't utf-8 decode this mess")
            );
            value
        }
        // if it fails, it's probably fine to return the bare bytes as they're already a string?
        Err(error) => {
            debug!("Failed to inflate bytes ({:?})", error);
            base64_decoded_samlrequest
        }
    };
    match from_utf8(&inflated_result) {
        Ok(value) => Ok(value.to_string()),
        _ => Err(AuthnDecodeError::new(format!(
            "Failed to utf-8 encode the result: {:?}",
            inflated_result
        ))),
    }
}

/// Used inside AuthnRequestParser to help parse the AuthN request
fn set_once_string_field(
    target: &mut Option<String>,
    field: &'static str,
    value: &str,
) -> Result<(), AuthnDecodeError> {
    if target.is_some() {
        return Err(AuthnDecodeError::new(format!(
            "AuthnRequest has duplicate {} attribute",
            field
        )));
    }
    *target = Some(value.to_string());
    Ok(())
}

/// Used inside AuthnRequestParser to help parse the AuthN request
fn parse_authn_tokenizer_attribute(
    local: StrSpan,
    value: StrSpan,
    mut req: AuthnRequestParser,
    inside_authn_request_root: bool,
) -> Result<AuthnRequestParser, AuthnDecodeError> {
    if !inside_authn_request_root {
        return Ok(req);
    }

    match local.to_lowercase().as_str() {
        "destination" => {
            set_once_string_field(&mut req.destination, "Destination", value.as_str())?;
        }
        "id" => {
            set_once_string_field(&mut req.request_id, "ID", value.as_str())?;
        }
        "issueinstant" => {
            debug!("Found issueinstant: {}", value);
            let parsed_datetime = DateTime::parse_from_rfc3339(&value);
            debug!("parsed_datetime: {:?}", parsed_datetime);
            match parsed_datetime {
                Ok(value) => {
                    if req.issue_instant.is_some() {
                        return Err(AuthnDecodeError::new(
                            "AuthnRequest has duplicate IssueInstant attribute".to_string(),
                        ));
                    }
                    req.issue_instant = Some(value.into());
                }
                Err(error) => {
                    return Err(AuthnDecodeError::new(format!(
                        "Failed to parse IssueInstant value {:?}: {}",
                        value.to_string(),
                        error
                    )));
                }
            };
        }
        "assertionconsumerserviceurl" => {
            set_once_string_field(
                &mut req.consumer_service_url,
                "AssertionConsumerServiceURL",
                value.as_str(),
            )?;
        }
        "version" => {
            if value != "2.0" {
                return Err(AuthnDecodeError::new(format!(
                    "SAML Request where version!=2.0 ({}), this is probably bad.",
                    value
                )));
            }
            req.version = value.to_string();
        }
        _ => debug!(
            "Found tokenizer attribute={}, value={}",
            local.to_lowercase().as_str(),
            value
        ),
    }

    //error!("after block {:?}", req.issue_instant);
    Ok(req)
}

/// Give it a string full of XML and it'll give you back a [AuthnRequest] object which has the details
// TODO: turn this into a `TryFrom<&str>` for AuthnRequest and return a Result so we can handle errors better
pub fn parse_authn_request(request_data: &str) -> Result<AuthnRequest, AuthnDecodeError> {
    let policy = security::SecurityPolicy::default().effective();
    if let Err(error) = security::inspect_xml_payload(request_data, policy.xml_limits) {
        return Err(AuthnDecodeError::new(format!(
            "AuthnRequest XML preflight check failed: {}",
            error
        )));
    }

    let mut saml_request = AuthnRequestParser::new();
    let mut current_depth = 0usize;
    let mut current_element = String::new();
    let mut authn_request_depth: Option<usize> = None;

    let tokenizer = xmlparser::Tokenizer::from(request_data);
    for token in tokenizer {
        match token {
            Ok(token_value) => {
                saml_request = match token_value {
                    Token::Attribute {
                        prefix: _,
                        local,
                        value,
                        span: _,
                    } => {
                        let inside_authn_request_root = authn_request_depth == Some(current_depth)
                            && current_element.eq_ignore_ascii_case("authnrequest");
                        match parse_authn_tokenizer_attribute(
                            local,
                            value,
                            saml_request,
                            inside_authn_request_root,
                        ) {
                            Ok(value) => value,
                            Err(error) => {
                                return Err(AuthnDecodeError::new(format!(
                                    "Failed to parse authn request: {:?}",
                                    error
                                )));
                            }
                        }
                    }
                    Token::ElementStart {
                        prefix: _,
                        local,
                        span: _,
                    } => {
                        current_depth = current_depth.saturating_add(1);
                        current_element = local.to_string();
                        if local.as_str().eq_ignore_ascii_case("authnrequest") {
                            if authn_request_depth.is_some() {
                                return Err(AuthnDecodeError::new(
                                    "AuthnRequest contains nested/duplicate AuthnRequest elements"
                                        .to_string(),
                                ));
                            }
                            authn_request_depth = Some(current_depth);
                        }

                        if local.as_str().eq_ignore_ascii_case("issuer") {
                            if saml_request.issuer_state != 0 {
                                return Err(AuthnDecodeError::new(
                                    "AuthnRequest contains duplicate Issuer elements".to_string(),
                                ));
                            }
                            saml_request.issuer_state = 1;
                        }
                        saml_request
                    }
                    Token::ElementEnd { end, .. } => {
                        let mut saw_issuer_close_without_text = false;
                        let mut saw_authn_request_close = false;
                        match end {
                            ElementEnd::Open => {}
                            ElementEnd::Empty => {
                                if current_depth == 0 {
                                    return Err(AuthnDecodeError::new(
                                        "Malformed AuthnRequest XML nesting".to_string(),
                                    ));
                                }
                                if current_element.eq_ignore_ascii_case("issuer")
                                    && saml_request.issuer_state == 1
                                {
                                    saw_issuer_close_without_text = true;
                                }
                                if current_element.eq_ignore_ascii_case("authnrequest")
                                    && authn_request_depth == Some(current_depth)
                                {
                                    saw_authn_request_close = true;
                                }
                                current_depth -= 1;
                            }
                            ElementEnd::Close(_, local) => {
                                if current_depth == 0 {
                                    return Err(AuthnDecodeError::new(
                                        "Malformed AuthnRequest XML nesting".to_string(),
                                    ));
                                }
                                if local.as_str().eq_ignore_ascii_case("issuer")
                                    && saml_request.issuer_state == 1
                                {
                                    saw_issuer_close_without_text = true;
                                }
                                if local.as_str().eq_ignore_ascii_case("authnrequest")
                                    && authn_request_depth == Some(current_depth)
                                {
                                    saw_authn_request_close = true;
                                }
                                current_depth -= 1;
                            }
                        }
                        if saw_issuer_close_without_text {
                            return Err(AuthnDecodeError::new(
                                "Issuer element was present but empty".to_string(),
                            ));
                        }
                        if saw_authn_request_close {
                            authn_request_depth = None;
                        }
                        saml_request
                    }
                    Token::Text { text } => {
                        if saml_request.issuer_state == 1 {
                            if saml_request.issuer.is_some() {
                                return Err(AuthnDecodeError::new(
                                    "AuthnRequest contains multiple Issuer values".to_string(),
                                ));
                            }
                            saml_request.issuer = Some(text.as_str().to_string());
                            saml_request.issuer_state = -1;
                        }
                        saml_request
                    }
                    _ => saml_request,
                };
            }
            Err(ref error) => {
                return Err(AuthnDecodeError::new(format!(
                    "Error parsing token: {:?}\n{:?}",
                    error, request_data
                )));
            }
        }
    }

    if authn_request_depth.is_some() {
        return Err(AuthnDecodeError::new(
            "AuthnRequest root element did not close".to_string(),
        ));
    }
    if saml_request.issuer_state == 1 {
        return Err(AuthnDecodeError::new(
            "Issuer element was opened but no value was parsed".to_string(),
        ));
    }

    AuthnRequest::try_from(saml_request)
}

// TODO: This has some interesting code for parsing and handling assertions etc
// https://docs.rs/crate/saml2aws-auto/1.10.1/source/src/saml/mod.rs
// use crate::prelude::*;

fn _get_private_key() {
    println!("Generating private key");
    // let rsa = Rsa::generate(2048).unwrap()
    // println!("Dumping RSA Cert {:?}", rsa.private_key_to_der());
    // let data = b"foobar";
    // let mut buf = vec![0; rsa.size() as usize];
    // let encrypted_result = rsa.public_encrypt(data, &mut buf, Padding::PKCS1);
    // println!("Dumping encrypted thing: {:?}", &encrypted_result);
    // let encrypted_len = &encrypted_result.unwrap();

    // println!("Length of encrypted thing: {:?}", encrypted_len);
}

// fn get_public_cert_base64(cert_path: std::string::String) -> Result<Certificate, ()> {
//     let mut buf = Vec::new();
//     let file = match File::open("certpath") {
//         Ok(file) => file,
//         Err(_) => Err
//     }
//     .read_to_end(&mut buf)?;
//     let cert = Certificate::from_der(&buf)?;
//     // cert.to_string()?
//     // .read_to_end(&mut buf)?;

//     // let mut encoded_cert = String::from("hello world");
//     // encoded_cert.push_str(&cert_path);
//     // return encoded_cert

// }

// fn encode_cert_as_base64_der() -> std::string::String{

//     use std::io::Write;
//     let mut buf = String::new();

//     let mut base64_encoder = base64::write::EncoderStringWriter::from(&mut buf, base64::STANDARD);

//     // enc.write_all(b"asdf").unwrap();
//     base64_encoder.write_all(generate_cert("www.example.com")).unwrap();

//     // release the &mut reference on buf
//     let _ = base64_encoder.into_inner();
//     buf
//     // assert_eq!("base64: YXNkZg==", &buf);
//     /*
//     pub fn Rsa.private_key_to_der(&self) -> Result<Vec<u8>, ErrorStack>
// Serializes the private key to a DER-encoded PKCS#1 RSAPrivateKey structure.

// This corresponds to i2d_RSAPrivateKey.
// */
// }
